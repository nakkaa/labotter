// ラボ入退室記録アプリ らぼったあ
// Version 0.82 (2016/07/21)
// 作った人:nakkaa

//定数
VERSION=「0.82」//バージョン番号
EDITION=「Beta」//テスト版かどうか
WINDOW_TITLE=「らぼったあ」//ウィンドウのタイトル
プログラム側キーとは文字列//Twitterのアプリ側トークンキー
プログラム側シークレットとは文字列//Twitterのアプリ側シークレットキー

//文字列
入室文=「ラボインしました！」//Tweetする内容
退室文=「らぼりだしました！」
ハッシュタグ=「#らぼったあ」
後付文=「https://7ka.org/software/labotter」
入室ボタン名=「らぼいん」
退室ボタン名=「らぼりだ」
ミューキーワード=『らぼったあ』//このキーワードが被ったら多重起動となる

//各種フラグ
twi_flag=0 //Twitter機能を使うかどうか(0:無効 1:有効)
LAST_ID=0 //研究室の入室状態が継続中か(0:継続していない(退室中))
Memo_flag=1 //メモ機能のフラグ
メモ内容は空

//ファイルの保存場所など
DB保存先=母艦パス&「labotime.db」//入退室時刻のデータベースの保存先
設定保存先=母艦パス&「setting.ini」 //各種設定保存先(v0.1〜)
キー保存先=「key.txt」
//SQLITE3をなでしこで使うときに必要。文字コードを勝手に変換してくれる
SQLITE3自動変換=オン

//デフォルトのフォント
文字書体は『Meiryo UI』

//メインウィンドウの設定
!母艦設計=『母艦の可視はオフ』


母艦について
　タイトルは「{WINDOW_TITLE}」
　H=350
　W=300
　オフに最大化ボタン有効変更
　背景色はウィンドウ背景色
　スタイルは「枠固定」　
　閉じた時は〜
　　終了処理

//起動時に行う処理
起動時処理

//GUI設計 ここから

//Twitterクライアントの生成
なこったークライアントとはNakotter
そのoauthのコンシューマのトークンキー＝プログラム側キー。
そのoauthのコンシューマのシークレット＝プログラム側シークレット。

//らぼいんボタン
入室ボタンとはボタン
これについて
　X=10。H=50。W=110。Y=30。
　クリックした時は〜
　　入室処理


//らぼあうとボタン
退室ボタンとはボタン
これについて
　X=150。H=50。W=110。Y=30
　クリックした時は〜
　　退室処理
　

ステバーとはステータスバー

履歴ボタンとはボタン
これについて
　テキストは「履歴」
　W=110
　H=40
　Y=150
　クリックした時は〜
　　履歴ウィンドウを中央移動
　　履歴描画処理
　　履歴ウィンドウをモーダル表示
　

設定とはボタン
これについて
　W=110
　H=40
　Y=150
　X=150
　クリックした時は〜
　　設定ウィンドウ開処理

情報ラベルとはラベル
これについて
　X=10
　Y=200
　テキストは「バージョン {VERSION} {EDITION}{~}なでしこバージョン {ナデシコバージョン}」


//最新版確認ボタン
最新版確認とはボタン
これについて
　W=150。Y=260
　テキストは「最新版はありません」
　有効はオフ
　


入室情報とはラベル
これについて
　テキストは「{入室ボタン名}：」
　Y=100
　
退室情報とはラベル
これについて
　テキストは「{退室ボタン名}：」
　Y=120
　

//入退室記録ウィンドウ
履歴ウィンドウとはフォーム
これについて
　タイトルは「履歴」
　W=800
　H=500
　オフに最小化ボタン有効変更

直近入退室履歴とはグリッド
そのレイアウトは「全体」
その親部品は履歴ウィンドウ
その編集はオフ
そのダブルクリックした時は〜
　削除処理
そのクリックした時は〜
　修正時刻反映処理

履歴バーとはパネル
そのレイアウトは「上」
そのスタイルは「凸」
その背景色はウィンドウ背景色
その親部品は履歴ウィンドウ

履歴出力とはボタン
その親部品は履歴バー
そのX=10
そのY=10
そのW=150
そのテキストは「CSVファイルで出力」
そのクリックした時は〜
　履歴出力処理

履歴検索ラベルとはラベル
その親部品は履歴バー
そのX=200
そのY=15
そのW=25
そのテキストは「検索：」

履歴編集とはエディタ
その親部品は履歴バー
そのX=240
そのY=10
そのW=150
そのテキストは「」
その変更した時は〜
　DB検索処理

　

履歴ステータスバーとはエディタ
これについて
　レイアウトは「下」
　編集はオフ
　背景色はウィンドウ背景色
　親部品は履歴ウィンドウ

サイドバーとはパネル
そのレイアウトは「右」
そのW=250
その背景色はウィンドウ背景色
その親部品は履歴ウィンドウ

日時表示とはエディタ
その親部品はサイドバー
そのX=10
そのY=200

日時とはカレンダー
その親部品はサイドバー
そのX=10
そのY=10
そのダブルクリックした時は〜
　選択日付は日時のテキスト
　日時表示のテキストはそれ




時間とはスピンエディタ
その最小値は00
その最大値は23
そのW=40
そのX=10
そのY=250
その親部品はサイドバー

分とはスピンエディタ
その最小値は00
その最大値は59
そのW=40
そのX=90
そのY=250
その親部品はサイドバー

秒とはスピンエディタ
その最小値は00
その最大値は59
そのW=40
そのX=170
そのY=250
その親部品はサイドバー

時間単位とはラベル
そのY=255
そのX=50
そのテキストは「　時　　　　　  　分　　　　  　　　秒」
その親部品はサイドバー

適用とはボタン
その親部品はサイドバー
そのX=60
そのY=300
そのW=170
そのテキストは「らぼりだの日付と時刻を修正」
そのクリックした時は〜
　選択日付は日時表示のテキスト
　修正時間=「{選択日付} {時間のテキスト}:{分のテキスト}:{秒のテキスト}」を「yyyy-mm-dd hh:nn:ss」に日時形式変換
　「UPDATE ltt set end = '」&修正時間&「' where id = 」&修正ID&「;」をSQLITE3実行
　履歴描画処理
　修正時刻反映処理

●修正時刻反映処理
　直近入退室履歴のテキストを修正データへ代入
　修正ID=修正データ\0\0
　もし、修正ID=0ならば、抜ける
　修正元データ=修正データ\0\2
　もし、修正元データが空ならば、抜ける
　選択日付=修正元データを「yyyy/mm/dd」に日時形式変換
　選択時刻=修正元データを「hh:mm:ss」に日時形式変換
　日時のテキストは選択日付
　日時表示のテキストは選択日付
　選択時刻を「:」で区切って時間フォーマットへ代入
　時間のテキストは時間フォーマット\0
　分のテキストは時間フォーマット\1
　秒のテキストは時間フォーマット\2
　日付表示のテキストは選択日付

//設定ウィンドウ関連
設定ウィンドウとはフォーム
これについて
　クライアントW=384#数値
　クライアントH=264#数値
　タイトル=「設定」#文字列
　スタイルは「ダイアログスタイル」
　背景色はウィンドウ背景色
※ ---
ボタン1とはボタン##生成
そのX=144#数値
そのY=208#数値
そのW=96#数値
そのH=32#数値
そのテキスト=「OK」#文字列
そのクリックした時は〜ボタン1__クリックした時#イベント
その親部品は設定ウィンドウ
※ ---
ボタン2とはボタン##生成
そのX=248#数値
そのY=208#数値
そのW=96#数値
そのH=32#数値
そのテキスト=「キャンセル」#文字列
そのクリックした時は〜ボタン2__クリックした時#イベント
その親部品は設定ウィンドウ
※ ---
エディタ1とはエディタ##生成
そのX=128#数値
そのY=24#数値
そのW=232#数値
そのH=24#数値
そのテキスト=「」#文字列
その親部品は設定ウィンドウ
※ ---
エディタ2とはエディタ##生成
そのX=128#数値
そのY=64#数値
そのW=232#数値
そのH=24#数値
そのテキスト=「」#文字列
その親部品は設定ウィンドウ
※ ---
エディタ3とはエディタ##生成
そのX=128#数値
そのY=104#数値
そのW=232#数値
そのH=24#数値
そのテキスト=「」#文字列
その親部品は設定ウィンドウ
※ ---
ラベル2とはラベル##生成
そのX=8#数値
そのY=24#数値
そのW=104#数値
そのH=32#数値
そのテキスト=「入室時つぶやく文」#文字列
その親部品は設定ウィンドウ
※ ---
ラベル3とはラベル##生成
そのX=8#数値
そのY=64#数値
そのW=104#数値
そのH=32#数値
そのテキスト=「退室時つぶやく文」#文字列
その親部品は設定ウィンドウ
※ ---
ラベル4とはラベル##生成
そのX=8#数値
そのY=104#数値
そのW=104#数値
そのH=32#数値
そのテキスト=「ハッシュタグ」#文字列
その親部品は設定ウィンドウ

TWIとはボタン
これについて
　W=110
　H=40
　Y=150
　X=10
　親部品は設定ウィンドウ
　クリックした時は〜
　　もし、twi_flag==0ならば、
　　　twi_setting_load
　　違えば、
　　　twi_setting_delete
//設定ウィンドウ関連ここまで

//GUI ここまで

入室ボタンのテキストは入室ボタン名
退室ボタンのテキストは退室ボタン名
TWIのテキストは「Twitter認証」

設定読込処理

もし、コマンドラインが「*-labout*」にワイルドカード一致ならば、
　退室処理
　終了処理

最新版確認処理
母艦を中央移動
母艦の可視はオン
設定ウィンドウを中央移動

●入室処理
　現在時刻=(今日の「/」を「-」に置換)&「 」&今
　「INSERT INTO ltt(start) values('」&現在時刻&「');」をSQLITE3実行
　LAST_ID=SQLITE3今挿入したID//をtmpへ登録(アプリ終了しても値を保持するために)
　//「UPDATE tmp set last = '」&SQLITE3今挿入したID&「';」をSQLITE3実行
　入室情報のテキストは「{入室ボタン名}：{現在時刻}」
　退室情報のテキストは「{退室ボタン名}：」
　twi_labo_in
　入室ボタンの有効はオフ
　退室ボタンの有効はオン

●退室処理
　もし、LAST_ID!=0ならば、
　　もし、Memo_flag==1ならば、
　　　メモ内容=「進捗状況等のメモがあれば記入」と尋ねる
　　違えば、メモ内容=空
　　現在時刻=(今日の「/」を「-」に置換)&「 」&今
　　「UPDATE ltt set end = '{現在時刻}',memo = '{メモ内容}' where id = {LAST_ID};」をSQLITE3実行。
　　退室情報のテキストは「{退室ボタン名}：{現在時刻}」
　　twi_labo_out
　　退室ボタンの有効はオフ
　　入室ボタンの有効はオン
　　LAST_ID=0
●履歴描画処理
　DB検索処理

●履歴出力処理
　CSV保存先=「csv」の「」で保存ファイル選択
　もし、CSV保存先が空でなければ、直近入退室履歴のアイテムをCSV保存先へ保存

●起動時処理
　エラー監視
　　キー保存先を開いてTwiKeyへ代入
　　プログラム側キー=TwiKey\0
　　プログラム側シークレット=TwiKey\1
　エラーならば、「[Key読み込みエラー]」という
　初期設定処理
　もし、DB保存先が存在でなければ、
　　DB保存先をSQLITE3開く。
　　「CREATE TABLE ltt(id INTEGER PRIMARY KEY,start TEXT,end TEXT,memo TEXT);」をSQLITE3実行。
　違えば、
　　DB保存先をSQLITE3開く。

●終了処理
　設定保存先のINI開いて設定ハンドルへ代入
　設定ハンドルで「設定」の「Twitter」にtwi_flagをINI書く
　設定ハンドルで「設定」の「最後に挿入したID」にLAST_IDをINI書く
　設定ハンドルのINI閉じる
　DB保存先のSQLITE3閉じる
　ReleaseMutex(ミューテックス)。
　CloseHandle(ミューテックス)。
　終了

●削除処理
　削除ID=直近入退室履歴のテキストの「"」から「"」まで範囲内切り取る
　もし、(削除ID==0)または(削除ID==LAST_ID)でなければ、
　　「以下の項目を削除しますか？{~}{~}{直近入退室履歴のテキスト}」を二択
　　もし、それがはいならば、
　　　「DELETE FROM ltt WHERE id=」&削除ID&「;」をSQLITE3実行。
　履歴描画処理
　
●最新版確認処理
　エラー監視
　　経過ダイアログはオフ
　　「https://7ka.org/file/ltr/version.txt」からHTTPデータ取得して最新版情報へ代入
　　もし、最新版情報\0>VERSIONならば、
　　　最新版確認の可視はオン
　　　最新版確認のテキストは「アプリの最新版があります」
　　　最新版確認のクリックした時は〜
　　　　最新版情報\1を起動
　エラーならば、抜ける

●設定読込処理
　設定保存先のINI開いて設定ハンドルに代入。
　設定ハンドルで「設定」の「Twitter」をINI読んでtwi_flagへ代入
　設定ハンドルで「設定」の「最後に挿入したID」をINI読んでLAST_IDへ代入
　設定ハンドルで「カスタマイズ」の「入室文」をINI読んで入室文へ代入
　設定ハンドルで「カスタマイズ」の「退室文」をINI読んで退室文へ代入
　設定ハンドルで「カスタマイズ」の「ハッシュタグ」をINI読んでハッシュタグへ代入
　設定ハンドルで「カスタマイズ」の「後付文」をINI読んで後付文へ代入
　設定ハンドルのINI閉じる
　もし、LAST_ID==0ならば、
　　退室ボタンの有効はオフ
　違えば、
　　入室ボタンの有効はオフ
　　入室時間=「SELECT start FROM ltt WHERE id=」&LAST_ID&「;」をSQLITE3実行
　　入室情報のテキストは「らぼいん：{入室時間\1}」
　//
　もし、twi_flag=1ならば、twi_setting_load
　設定情報描画処理

//初回起動時の設定
●初期設定処理
　もし、設定保存先が存在でなければ、
　　設定保存先のINI開いて設定ハンドルへ代入
　　設定ハンドルで「設定」の「VERSION」にVERSIONをINI書く
　　設定ハンドルで「設定」の「最後に挿入したID」に「0」をINI書く
　　設定ハンドルで「設定」の「Twitter」に「0」をINI書く
　　設定ハンドルで「カスタマイズ」の「入室文」に入室文をINI書く
　　設定ハンドルで「カスタマイズ」の「退室文」に退室文をINI書く
　　設定ハンドルで「カスタマイズ」の「ハッシュタグ」にハッシュタグをINI書く
　　設定ハンドルで「カスタマイズ」の「後付文」に後付文をINI書く
　　設定ハンドルのINI閉じる
　　
//設定ウィンドウ関連
●ボタン2__クリックした時
　　設定ウィンドウを閉じる

●ボタン1__クリックした時
　　設定情報上書保存処理

●設定情報描画処理
　エディタ1のテキストは入室文
　エディタ2のテキストは退室文
　エディタ3のテキストはハッシュタグ

●設定情報上書保存処理
　入室文はエディタ1のテキスト
　退室文はエディタ2のテキスト
　ハッシュタグはエディタ3のテキスト
　設定保存先のINI開いて設定ハンドルに代入
　設定ハンドルで「カスタマイズ」の「入室文」に入室文をINI書く
　設定ハンドルで「カスタマイズ」の「退室文」に退室文をINI書く
　設定ハンドルで「カスタマイズ」の「ハッシュタグ」にハッシュタグをINI書く
　設定ウィンドウを閉じる
　設定ハンドルのINI閉じる

●設定ウィンドウ開処理
　設定ウィンドウを中央移動
　設定情報描画処理
　設定ウィンドウをモーダル表示

●DB検索処理
　検索抽出結果=「SELECT id AS "ID", start AS "らぼいん", end AS "らぼりだ",cast((julianday(end) - julianday(start)) as integer)||":"||(time(strftime('%s', end, 'localtime') - strftime('%s', start, 'localtime'),'unixepoch')) as "滞在時間",memo AS "メモ" from ltt where start LIKE '%{履歴編集のテキスト}%' or end LIKE '%{履歴編集のテキスト}%' or memo LIKE '%{履歴編集のテキスト}%' ORDER BY id DESC;」をSQLITE3実行
　累計滞在時間=「SELECT cast((sum(julianday(end) - julianday(start)))%24 as int)||"日"||cast((sum(julianday(end) - julianday(start))*24)%24 as int)||"時間"||cast((sum(julianday(end) - julianday(start))*24*60)%60 as int)||"分" from ltt where start LIKE '%{履歴編集のテキスト}%' or end LIKE '%{履歴編集のテキスト}%' ORDER BY id DESC;」をSQLITE3実行
　平均滞在時間=「SELECT cast((avg(julianday(end) - julianday(start)))%24 as int)||"日"||cast((avg(julianday(end) - julianday(start))*24)%24 as int)||"時間"||cast((avg(julianday(end) - julianday(start))*24*60)%60 as int)||"分" from ltt where start LIKE '%{履歴編集のテキスト}%' or end LIKE '%{履歴編集のテキスト}%' ORDER BY id DESC;」をSQLITE3実行
　履歴ステータスバーのテキストは「累計時間は{累計滞在時間\1}　平均時間は{平均滞在時間\1}」
　直近入退室履歴のアイテムは検索抽出結果
//Twitter処理関係
●twi_oauth
　エラー監視
　　なこったークライアントで認証する。
　　認証情報はそれ。
　　設定保存先のINI開いて設定ハンドルへ代入
　　設定ハンドルで「設定」の「トークンキー」に「{認証情報@oauth_token}」をINI書く
　　設定ハンドルで「設定」の「トークンシークレットキー」に「{認証情報@oauth_token_secret}」をINI書く
　　設定ハンドルのINI閉じる
　エラーならば、
　　twi_nako_error_view

●twi_setting_load
　エラー監視
　　もし、twi_flag==0ならば、twi_oauth
　　設定保存先のINI開いて設定ハンドルに代入。
　　設定ハンドルで「設定」の「トークンキー」をINI読んでTWI_TOKEN_KEYへ代入
　　設定ハンドルで「設定」の「トークンシークレットキー」をINI読んでTWI_TOKEN_SECRETへ代入
　　設定ハンドルのINI閉じる
　　もし、(TWI_TOKEN_KEY==空)または(TWI_TOKEN_SECRET==空)ならば、
　　　ステバーのテキストは「認証キーがありません」
　　　twi_flag=0
　　違えば、
　　　なこったークライアントのoauthのトークンキー=TWI_TOKEN_KEY
　　　なこったークライアントのoauthのシークレット=TWI_TOKEN_SECRET
　　　twi_flag=1
　　twi_button_refresh
　エラーならば、
　　エラーメッセージをいう
　　twi_nako_error_view

●twi_setting_delete
　twi_flag=0
　設定保存先のINI開いて設定ハンドルへ代入
　設定ハンドルで「設定」の「トークンキー」に「」をINI書く
　設定ハンドルで「設定」の「トークンシークレットキー」に「」をINI書く
　設定ハンドルのINI閉じる
　twi_button_refresh

●twi_labo_in
　もし、twi_flag==1ならば、
　　エラー監視
　　　なこったークライアントから「{入室文}{現在時刻} {後付文} {ハッシュタグ}」とつぶやく
　　　それでtwi_tweet_error_check
　　エラーならば、twi_nako_error_view
●twi_labo_out
　もし、twi_flag==1ならば、
　　エラー監視
　　　//累計時刻=『SELECT (time(strftime('%s', end, 'localtime') - strftime('%s', start, 'localtime'),'unixepoch')) as "らぼ滞在時間" from ltt where id=』&LAST_ID&『;』をSQLITE3実行
　　　累計時刻=「SELECT cast((sum(julianday(end) - julianday(start)))%24 as int)||"日"||cast((sum(julianday(end) - julianday(start))*24)%24 as int)||"時間"||cast((sum(julianday(end) - julianday(start))*24*60)%60 as int)||"分" from ltt where id = {LAST_ID};」をSQLITE3実行
　　　なこったークライアントから「{退室文}{現在時刻} 今回のらぼ滞在時間は{累計時刻\1}でした。 {後付文} {ハッシュタグ}」とつぶやく
　　　それでtwi_tweet_error_check
　　エラーならば、twi_nako_error_view
●twi_tweet_error_check(Sで)
　もし、Sが「errors*」に一致ならば、//エラーならば
　　//S@`errors`@`code`をいう //220
　　ステバーのテキストは「Twitter接続エラー(コード:{S@`errors`@`code`})」
　違えば、
　　ステバーのテキストは「Twitterにつぶやきました」//{~}{S@`user`@`name`}{~}{S@`text`}」

●twi_button_refresh
　もし、twi_flag==1ならば、
　　TWIのテキストは「Twitter認証解除」
　　ステバーのテキストは「Twitter認証済み」
　違えば、
　　TWIのテキストは「Twitter認証」
　　ステバーのテキストは「Twitter未認証」
　　
●twi_nako_error_view
　ステバーのテキストは「エラーが発生しました(Twitterに接続不可)」
　　
# nakotter ver.0.43
# http://www.undefin.net/nadesiko/nako/nakotter-ver.0.42.zip

！変数宣言は必要

●UNIX時間取得
　今日&` `&今をUNIXTIME変換

#resource http://nadesiko.g.hatena.ne.jp/white-ball/20100402/1270147724

●HMACSHA1取得(秘密鍵で内容の)
　Bとは整数=64。Lとは整数=20
　＃秘密鍵の長さの調整
　秘密鍵のバイト数
　もしそれ＞Bならば
　　秘密鍵からSHA1取得
　　2で行揃え
　　反復
　　　INT(「$」＆対象)を秘密鍵の回数に「byte」でバイナリ設定＃ハッシュ関数の出力のバイナリ変換
　　秘密鍵は秘密鍵のL バイト左部分
　　秘密鍵のバイト数
　もしそれ＜Bならば
　　「{\0}」を(B-それ)だけリフレイン
　　秘密鍵は秘密鍵&それ
　
　＃鍵から作る2つの文字列の準備
　鍵Iとは文字列。鍵IにBを確保
　鍵Oとは文字列。鍵OにBを確保
　文字とは整数
　B/4回
　　秘密鍵の(回数-1)*4+1 を「DWORD」でバイナリ取得
　　文字はそれ
　　XOR(文字,$36363636)を鍵Iの(回数-1)*4+1 に「DWORD」でバイナリ設定
　　XOR(文字,$5C5C5C5C)を鍵Oの(回数-1)*4+1 に「DWORD」でバイナリ設定
　
　＃ハッシュ関数の適用
　経過とは文字列
　経過にLを確保
　
　(鍵I＆内容)からSHA1取得
　2で行揃え
　反復
　　INT(「$」＆対象)を経過の回数に「byte」でバイナリ設定＃ハッシュ関数の出力のバイナリ変換
　
　(鍵O＆経過)からSHA1取得
　2で行揃え
　反復
　　INT(「$」＆対象)を経過の回数に「byte」でバイナリ設定＃ハッシュ関数の出力のバイナリ変換
　
　経過を戻す


# hmacsha1.nako
##############################


■トークン
　・{文字列}トークンキー
　・{文字列}シークレット

■OAuth　+トークン
　・{文字列}バージョン{="1.0"}
　・{文字列}署名方式{="HMAC-SHA1"}
　・{トークン}コンシューマ
　・{文字列}リクエストトークンURL
　・{文字列}アクセストークンURL
　・{文字列}認証URL
　・{トークン}リクエスト
　・{非公開}基本パラメータ生成({ハッシュ=?}PARAMから)〜
　　パラメータとはハッシュ = PARAM
　　パラメータ@『oauth_consumer_key』    = コンシューマのトークンキー
　　パラメータ@『oauth_nonce』           = GUID生成の11文字右部分を小文字変換
　　パラメータ@『oauth_signature_method』= 署名方式
　　パラメータ@『oauth_timestamp』       = UNIX時間取得
　　パラメータ@『oauth_version』         = バージョン
　　_ = パラメータ
　・{非公開}コンシューマチェック〜
　　もしコンシューマのトークンキーが空ならば
　　　『コンシューマのトークンキーが空です。』でエラー発生
　　もしコンシューマのシークレットが空ならば
　　　『コンシューマのシークレットが空です。』でエラー発生
　・HTTPリクエスト({文字列}URLへ{ハッシュ}PARAMで)〜
　　エラー監視
　　　URL&『?』&(PARAMのURLパラメータ変換)からHTTPデータ取得
　　エラーならば
　　　『HTTPリクエストに失敗。パラメータの指定が間違っている可能性があります。』でエラー発生
　・POST({文字列}URLへ{ハッシュ=?}PARAMで)〜
　　コンシューマチェック
　　鍵とは文字列 = (コンシューマのシークレット)&『&』&シークレット
　　基本パラメータとはハッシュ = 基本パラメータ生成
　　基本パラメータ@『oauth_token』= トークンキー
　　パラメータとはハッシュ。パラメータに基本パラメータをデータコピー
　　署名とは文字列 = 『POST&』&(URLをURLエンコード)&『&』
　　PARAMのハッシュキー列挙して反復、パラメータ@対象 = PARAM@対象
　　パラメータをURLパラメータ変換をURLエンコードを署名に追加
　　基本パラメータ@『oauth_signature』 = 鍵で署名の非公開署名生成をURLエンコード
　　HEADとは文字列 = 基本パラメータからヘッダ生成
　　HEADに"{\13}{\10}" & `Content-Type: application/x-www-form-urlencoded` & "{\13}{\10}"を追加
　　BODYとは文字列 = PARAMをURLパラメータ変換
　　それは空。HEADとBODYをURLへHTTPポスト
　・GET({文字列}URLへ{ハッシュ=?}PARAMで)〜
　　コンシューマチェック
　　鍵とは文字列 = (コンシューマのシークレット)&『&』&シークレット
　　基本パラメータとはハッシュ = 基本パラメータ生成
　　基本パラメータ@『oauth_token』= トークンキー
　　パラメータとはハッシュ。パラメータに基本パラメータをデータコピー
　　署名とは文字列 = 『GET&』&(URLをURLエンコード)&『&』
　　PARAMのハッシュキー列挙して反復、パラメータ@対象 = PARAM@対象
　　パラメータをURLパラメータ変換をURLエンコードを署名に追加
　　基本パラメータ@『oauth_signature』 = 鍵で署名の非公開署名生成をURLエンコード
　　HEADとは文字列 = 基本パラメータからヘッダ生成
　　もしPARAMのハッシュキー列挙の要素数が0でなければ
　　　URLに『?』&(PARAMをURLパラメータ変換)を追加
　　それは空。HEADをURLへHTTPゲット
　・リクエストトークン取得処理〜
　　コンシューマチェック
　　パラメータとはハッシュ = 基本パラメータ生成
　　鍵とは文字列   = (コンシューマのシークレット)&『&』
　　署名とは文字列 = 『GET&』&(リクエストトークンURLをURLエンコード)&『&』
　　パラメータをURLパラメータ変換をURLエンコードを署名に追加
　　パラメータ@『oauth_signature』 = 鍵で署名の非公開署名生成
　　リクエストトークン結果とはハッシュ
　　リクエストトークンURLへパラメータでHTTPリクエスト
　　リクエストトークン結果 = それの『&』を改行に置き換えてハッシュ変換
　　もしリクエストトークン結果@`oauth_callback_confirmed`が`true`でなければ
　　　『リクエストトークンの取得に失敗。パラメータの指定が間違っている可能性があります。』でエラー発生
　　リクエストのトークンキー = リクエストトークン結果@`oauth_token`
　　リクエストのシークレット = リクエストトークン結果@`oauth_token_secret`
　　_ = リクエストトークン結果
　・認証URL取得〜
　　認証URL&『?oauth_token=』&(リクエストのトークンキー)を戻す
　・アクセストークン取得処理({文字列}暗証番号で)〜
　　コンシューマチェック
　　パラメータとはハッシュ = 基本パラメータ生成
　　パラメータ@『oauth_token』    = リクエストのトークンキー
　　パラメータ@『oauth_verifier』 = 暗証番号
　　鍵とは文字列   = (コンシューマのシークレット)&『&』&(リクエストのシークレット)
　　署名とは文字列 = 『GET&』&(アクセストークンURLをURLエンコード)&『&』
　　パラメータをURLパラメータ変換をURLエンコードを署名に追加
　　パラメータ@『oauth_signature』 = 鍵で署名の非公開署名生成
　　アクセストークン結果とはハッシュ
　　アクセストークンURLへパラメータでHTTPリクエスト
　　アクセストークン結果 = それの『&』を改行に置き換えてハッシュ変換
　　トークンキー = アクセストークン結果@`oauth_token`
　　シークレット = アクセストークン結果@`oauth_token_secret`
　　_ = アクセストークン結果
　・{非公開}非公開署名生成(KEYでSTRの)〜
　　鍵とは文字列
　　鍵に64を確保
　　鍵 = KEY
　　鍵でSTRのHMACSHA1取得
　　それをBASE64エンコード
　・{非公開}ヘッダ生成({ハッシュ}PARAMから)〜
　　結果とは文字列 = 『Authorization: OAuth 』
　　『oauth_nonce,oauth_timestamp,oauth_consumer_key,oauth_signature_method,oauth_version,oauth_token,oauth_signature』を、
　　『,』で区切って反復
　　　結果に対象&『="』&(PARAM@対象)&『", 』を追加
　　結果から2文字右端削除
　　_ = 結果
　・URLパラメータ変換({ハッシュ}PARAMを|PARAMの)〜
　　結果とは文字列
　　KEYSとは配列=PARAMのハッシュキー列挙
　　KEYSを配列ソート
　　KEYSを反復
　　　結果に対象&『=』&(PARAM@対象をパラメータエンコード)&『&』を追加
　　結果から1文字右端削除
　・{非公開}パラメータエンコード({文字列}Sを)〜
　　SをUTF8N変換をURLエンコードの『+』を『%20』に置換



# lib\oauth.nako
##############################


# Cf. http://apiwiki.twitter.com/Twitter-API-Documentation

■Nakotter
　・{数値}バージョン{=0.43}
　・{文字列}APIURL{="https://api.twitter.com/1.1/"}
　・{文字列}フォーマット{=".json"}
　・{OAuth}oauth
　・レスポンス処理
　・ホームTL取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『statuses/home_timeline』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・ユーザTL取得({ハッシュ=?}PARAMで{文字列}IDNAMEの)〜
　　URLとは文字列 = APIURL & 『statuses/user_timeline』 & フォーマット
　　パラメータとはハッシュ = PARAM
　　パラメータにIDNAMEをIDNAME設定
　　URLへパラメータでoauth.GET
　　レスポンス処理。
　・返信取得({ハッシュ=?}PARAMで)〜
　　PARAMで返信一覧取得
　・返信一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『statuses/mentions_timeline』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・リツイート一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『statuses/retweets_of_me』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・つぶやき取得({ハッシュ=?}PARAMで{文字列}STATUS_IDを|STATUS_IDの)〜
　　URLとは文字列 = APIURL & 『statuses/show/』 & STATUS_ID & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・つぶやく({ハッシュ=?}PARAMで{文字列}STRと)〜
　　URLとは文字列 = APIURL & 『statuses/update』 & フォーマット
　　パラメータとはハッシュ = PARAM
　　パラメータ@`status` = STR
　　URLへパラメータでoauth.POST
　　レスポンス処理。
　・つぶやき削除({ハッシュ=?}PARAMで{文字列}STATUS_IDの)〜
　　URLとは文字列 = APIURL & 『statuses/destroy/』 & STATUS_ID & フォーマット
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・リツイート({文字列}STATUS_IDを)〜
　　URLとは文字列 = APIURL & 『statuses/retweet/』 & STATUS_ID & フォーマット
　　URLへoauth.POST
　　レスポンス処理。
　・リツイートしたユーザ一覧取得({ハッシュ=?}PARAMで{文字列}STATUS_IDを)〜
　　URLとは文字列 = APIURL & 『statuses/retweets/』 & STATUS_ID & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・ユーザ列挙({文字列}SCREEN_NAMESで|SCREEN_NAMESの)〜
　　URLとは文字列 = APIURL & 『users/lookup』 & フォーマット
　　PARAMとはハッシュ。
　　もしSCREEN_NAMESの変数型確認が`配列`ならば
　　　SCREEN_NAMES = SCREEN_NAMESを`,`で配列結合
　　PARAM@`screen_name` = SCREEN_NAMES
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・IDユーザ列挙({文字列}USER_IDSで|USER_IDSの)〜
　　URLとは文字列 = APIURL & 『users/lookup』 & フォーマット
　　PARAMとはハッシュ。
　　もしUSER_IDSの変数型確認が`配列`ならば
　　　USER_IDS = USER_IDSを`,`で配列結合
　　PARAM@`user_id` = USER_IDS
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・友達一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『friends/ids』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・フォロワー一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『followers/ids』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・受信DM一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『direct_messages』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・送信DM一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『direct_messages/sent』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・DM送信({文字列}IDNAMEへ{文字列}STRと|IDNAMEにSTRの|STRを)〜
　　URLとは文字列 = APIURL & 『direct_messages/new』 & フォーマット
　　PARAMとはハッシュ。
　　PARAMにIDNAMEをIDNAME設定
　　PARAM@`text` = STR
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・DM削除({文字列}IDの|IDを)〜
　　URLとは文字列 = APIURL & 『direct_messages/destroy』 & フォーマット
　　PARAMとはハッシュ
　　PARAM@`id` = ID
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・フォロー({文字列}IDNAMEを)〜
　　URLとは文字列 = APIURL & 『friendships/create』 & フォーマット
　　PARAMとはハッシュ。
　　PARAMにIDNAMEをIDNAME設定
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・リムーブ({文字列}IDNAMEを)〜
　　URLとは文字列 = APIURL & 『friendships/destroy』 & フォーマット
　　PARAMとはハッシュ。
　　PARAMにIDNAMEをIDNAME設定
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・フォロー関係取得({文字列}SOURCE_IDNAMEと{文字列}TARGET_IDNAMEの)〜
　　URLとは文字列 = APIURL & 『friendships/show』 & フォーマット
　　PARAMとはハッシュ。
　　PARAMにSOURCE_IDNAMEを`source_`へIDNAME設定
　　PARAMにTARGET_IDNAMEを`target_`へIDNAME設定
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・ふぁぼり一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『favorites/list』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・ふぁぼる({文字列}STATUS_IDを)〜
　　URLとは文字列 = APIURL & 『favorites/create』 & フォーマット
　　PARAMとはハッシュ
　　PARAM@`id` = STATUS_ID
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・ふぁぼり削除({文字列}STATUS_IDを|STATUS_IDの)〜
　　URLとは文字列 = APIURL & 『favorites/destroy』 & フォーマット
　　PARAMとはハッシュ
　　PARAM@`id` = STATUS_ID
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・ブロック({文字列}IDNAMEを)〜
　　URLとは文字列 = APIURL & 『blocks/create』 & フォーマット
　　PARAMとはハッシュ
　　PARAMにIDNAMEをIDNAME設定
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・ブロック解除({文字列}IDNAMEを|IDNAMEの)〜
　　URLとは文字列 = APIURL & 『blocks/destroy』 & フォーマット
　　PARAMとはハッシュ
　　PARAMにIDNAMEをIDNAME設定
　　URLへPARAMでoauth.POST
　　レスポンス処理。
　・ブロックユーザ一覧取得({ハッシュ=?}PARAMで)〜
　　URLとは文字列 = APIURL & 『blocks/list』 & フォーマット
　　URLへPARAMでoauth.GET
　　レスポンス処理。
　・API確認〜
　　URLとは文字列 = APIURL & 『help/tos』 & フォーマット
　　URLへoauth.GET
　　レスポンス処理。
　・返信する({文字列}STRと{文字列}STATUS_IDに|STATUS_IDへ)〜
　　パラメータとはハッシュ
　　パラメータ@`in_reply_to_status_id` = STATUS_ID
　　STRとパラメータでつぶやく
　・認証〜
　　oauthのリクエストトークン取得処理
　　oauthの認証URL取得してコピーして起動
　　3秒待つ。
　　TEMPとは整数 = ダイアログ数値変換
　　ダイアログ数値変換はオフ
　　『暗証番号は？』と尋ねる
　　oauthからそれでアクセストークン取得処理
　　ダイアログ数値変換 = TEMP
　・作る〜
　　# Twitter OAuth API
　　oauthのリクエストトークンURL      = 『https://api.twitter.com/oauth/request_token』
　　oauthのアクセストークンURL        = 『https://api.twitter.com/oauth/access_token』
　　oauthの認証URL                    = 『https://api.twitter.com/oauth/authorize』
　　# Nakotter コンシューマ
　　oauthのコンシューマのトークンキー = 『』
　　oauthのコンシューマのシークレット = 『』
　　# HTTP Response の処理。デフォルトでは JSON 想定
　　もしナデシコバージョン≦1.5329ならば
　　　レスポンス処理は
　　　　レスポンス部分
　　　　JSONデータ修正_nako_v_1_5329
　　違えば、もしナデシコバージョン≧1.533ならば
　　　レスポンス処理は
　　　　レスポンス部分
　　　　JSONデータ修正_nako_v_1_533
　　#違えば
　　#　レスポンス処理は〜レスポンス部分をJSONデコード
　・IDNAME設定({参照渡し ハッシュ}PARAMに{文字列}IDNAMEを{文字列=``}PREFIXへ)〜
　　もし、IDNAMEが`^[0-9]+$`に正規表現一致ならば、
　　　PARAM@"{PREFIX}user_id" = IDNAME
　　違えば、
　　　PARAM@"{PREFIX}screen_name" = IDNAME

●レスポンス部分
　　STRとは文字列 = それ
　　STRの改行&改行&改行まで切り取る
　　_ = STR
●JSONデータ修正_nako_v_1_5329
　　JSONデータ修正_HOTFIX_201010
　　それの『:null』を『:""』に置換の『:(\d{11,})』を『:"$1"』に正規表現置換をJSONデコード
●JSONデータ修正_nako_v_1_533
　　JSONデータ修正_HOTFIX_201010
　　それの『:null』を『:""』に置換をJSONデコード

UTF8変換テーブルとはハッシュ=『\u003C=<
\u003E=>』

●JSONデータ修正_HOTFIX_201010
　JSONとは文字列=それ
　UTF8変換テーブルのハッシュキー列挙して反復
　　JSON=JSONの対象をUTF8変換テーブル@対象に置換
　_=JSON

//多重起動の禁止
●CreateMutex(sec,owner,{参照渡し}neme) =DLL("kernel32.dll",
　"HANDLE CreateMutexA(
LONG pSAttr,//0固定
BOOL fOwner,//所有者
LPCTSTR sMutexName//オブジェクト名
)")
●ReleaseMutex(hMutex) =DLL("kernel32.dll",
　"BOOL ReleaseMutex(
HANDLE hMutex // ミューテックスのハンドル
)")
●CloseHandle(hObject)=DLL("kernel32.dll",
　"BOOL CloseHandle(
HANDLE hObject // オブジェクトのハンドル
)")
●GetLastError()=DLL("kernel32.dll","DWORD GetLastError()")
　ミューテックスはCreateMutex(0,0,ミューキーワード)
　GetLastError()
　もしそれが/*ERROR_ALREADY_EXISTS*/183ならば、多重起動検知処理。
●多重起動検知処理
　『既に起動しています』という。
　終わり。

// タスクトレイ右クリックメニュー
■POINT
　・X
　・Y

!POINT_TYPEとは文字列="DWORD,DWORD"

●GetCursorPos({参照渡し}p)=DLL("USER32.DLL",
"INT GetCursorPos(
char* pPoint)")

●GetMenu(hWnd)=DLL("USER32.DLL",
"DWORD GetMenu(DWORD hWnd)")

●GetSubMenu(hMenu,I)=DLL("USER32.DLL",
"DWORD GetSubMenu(
DWORD hWnd,
DWORD Index)")

●TrackPopupMenu(hMenu,f,x,y,r,hWnd,p)=DLL("USER32.DLL",
"Int TrackPopupMenu(
Int hMenu,
Int wFlags,
Int x,
Int y,
Int nReserved,
Int hWnd,
Int lPrc)")

●SetForegroundWindow(hWnd) =DLL("user32.dll",
"BOOL SetForegroundWindow(
HWND hWnd
)")